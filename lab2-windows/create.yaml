---

# Step 1 - Create a collection of EC2 instances and boot
# them.  No configuration beyond a simple boot will be done.

- name: "Create host instances."
  hosts: localhost
  gather_facts: false
  vars:
    aws_profile: "{{ lookup('env', 'AWS_PROFILE') }}"
    siduser: "{{ lookup('env', 'MYSIDLABS_USER') }}"


  roles:
    # Quick check to make sure the runtime env looks reasonable.
    - env_check

  tasks:
    - name: Provision and launch windows instances
      ec2_instance:
        name: "{{ siduser }}-{{ item.tier }}-{{ idx }}"
        image_id: "ami-09f37a557c2427a5f"
        instance_type: t3a.medium
        network:
          assign_public_ip: true
        key_name: "{{ aws_ssh_key_pair }}"
        region: "{{ region }}"
        security_group: ansible-winrm-enabled
        state: running
        tags:
          mysidlabs: "1"
          mysidlabs-tier: "ephemeral"
          mysidlabs_owner: "{{ siduser }}"
          mysidlabs_app_tier: "{{ item.tier }}"
          mysidlabs_type: "windows"
        volumes:
          - device_name: /dev/sda1
            ebs:
              delete_on_termination: true
        vpc_subnet_id: "{{ vpc_subnet }}"
        wait: true
        wait_timeout: 120
      loop:
        - { tier: "lb" }
        - { tier: "web" }
        - { tier: "web" }
      loop_control:
        index_var: idx
      register: ec2_result

    # - name: Provision and launch lb
    #   ec2_instance:
    #     name: "{{ siduser }}-{{ item.tier }}-{{ idx }}"
    #     image_id: "ami-01e36b7901e884a10"
    #     instance_type: "t3a.nano"
    #     network:
    #       assign_public_ip: true
    #     key_name: "{{ aws_ssh_key_pair }}"
    #     region: "{{ region }}"
    #     security_group: ssh-http-https
    #     state: running
    #     tags:
    #       mysidlabs: "1"
    #       mysidlabs-tier: "ephemeral"
    #       mysidlabs_owner: "{{ siduser }}"
    #       mysidlabs_app_tier: "lb"
    #       mysidlabs_type: "linux"
    #     volumes:
    #       - device_name: /dev/sda1
    #         ebs:
    #           delete_on_termination: true
    #     vpc_subnet_id: "{{ vpc_subnet }}"
    #     wait: true
    #     wait_timeout: 120
    #   loop:
    #     - { tier: "lb" }
    #   loop_control:
    #     index_var: idx
    #   register: ec2_result

    # Note that we're not doing anything with an inventory here.
    # In Lab1, we had the playbook also create the static 
    # inventory.  In this lab, we'll be using a dynamic inventory.

    - debug:
        msg: "{{ item.instances[0].tags.Name }} == Private IP: {{ item.instances[0].private_ip_address }}, Public IP: {{ item.instances[0].public_ip_address }}"
      loop: "{{ ec2_result.results }}"
      loop_control:
        label: ""
...
