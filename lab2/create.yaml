---

# Step 1 - Create a collection of EC2 instances and boot
# them.  No configuration beyond a simple boot will be done.

- name: "Create host instances"
  hosts: localhost
  gather_facts: false
  vars:
    aws_profile: "{{ lookup('env', 'AWS_PROFILE') }}"
    siduser: "{{ lookup('env', 'MYSIDLABS_USER') }}"

  roles:
    # Quick check to make sure the runtime env looks reasonable.
    - env_check

  tasks:

    - name: Provision and launch instances
      ec2_instance:
        name: "{{ siduser }}-{{ item.tier }}-{{ idx }}"
        image_id: "ami-01e36b7901e884a10"
        instance_type: "{{ instance_type }}"
        network:
          assign_public_ip: true
        key_name: "{{ aws_ssh_key_pair }}"
        region: "{{ region }}"
        security_group: "{{ security_group }}"
        tags:
          mysidlabs: "1"
          mysidlabs_owner: "{{ siduser }}"
          mysidlabs_tier: "{{ item.tier }}"
        volumes:
          - device_name: /dev/sda1
            ebs:
              delete_on_termination: true
        vpc_subnet_id: "{{ vpc_subnet }}"
        wait: true
      loop:
        - { tier: "lb" }
        - { tier: "web" }
        - { tier: "web" }
      loop_control:
        index_var: idx
      register: ec2_result

    # Note that we're not doing anything with an inventory here.
    # In Lab1, we had the playbook also create the static 
    # inventory.  In this lab, we'll be using a dynamic inventory.

    - debug:
        msg: "{{ item.instances[0].tags.Name }} == Private IP: {{ item.instances[0].private_ip_address }}, Public IP: {{ item.instances[0].public_ip_address }}"
      loop: "{{ ec2_result.results }}"
      loop_control:
        label: ""
...
